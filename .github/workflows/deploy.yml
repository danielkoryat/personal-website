name: Deploy to Home Server

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    env:
      CLOUDFLARED_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
      EMAIL_USER: ${{ secrets.EMAIL_USER }}
      EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
    
    steps:
    - name: 1. Checkout Code
      uses: actions/checkout@v4
    
    - name: 2. Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: 3. Create initial upstream config if needed
      run: |
        # This step is crucial for the very first deployment.
        # It ensures nginx has a valid include file to read on its first start.
        if [ ! -f active_upstream.conf ]; then
          echo "Creating initial active_upstream.conf, pointing to blue..."
          echo 'set $active_upstream daniel-koryat-portfolio-blue:3000;' > active_upstream.conf
        fi

    - name: 4. Ensure Core Infrastructure is Running
      run: |
        echo "ðŸŒ Ensuring nginx and cloudflared are running..."
        # This will now start nginx without error every time.
        docker compose up -d nginx
        
        # Wait for nginx to become healthy before starting cloudflared
        for i in {1..10}; do
          HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' portfolio-nginx 2>/dev/null || echo "starting")
          if [ "${HEALTH_STATUS}" == "healthy" ]; then
            echo "âœ… Nginx is healthy!"
            docker compose up -d cloudflared
            exit 0
          fi
          echo "   - Waiting for Nginx to be healthy... (Status: ${HEALTH_STATUS})"
          sleep 6
        done
        echo "âŒ Nginx failed to start. Check logs."
        docker compose logs nginx
        exit 1

    - name: 5. Determine Deployment Slots
      run: |
        if grep -q "blue" active_upstream.conf; then
          LIVE_SLOT="blue"
          DEPLOY_SLOT="green"
        else
          LIVE_SLOT="green"
          DEPLOY_SLOT="blue"
        fi
        echo "Live environment: ${LIVE_SLOT}"
        echo "Deploying to: ${DEPLOY_SLOT}"
        echo "LIVE_SLOT=${LIVE_SLOT}" >> $GITHUB_ENV
        echo "DEPLOY_SLOT=${DEPLOY_SLOT}" >> $GITHUB_ENV

    - name: 6. Build and Deploy New Version
      run: |
        echo "ðŸ”¨ Building and deploying portfolio-${{ env.DEPLOY_SLOT }}..."
        docker compose up -d --build --force-recreate "portfolio-${{ env.DEPLOY_SLOT }}"

    - name: 7. Wait for New Environment to be Healthy
      run: |
        CONTAINER_NAME="daniel-koryat-portfolio-${{ env.DEPLOY_SLOT }}"
        echo "ðŸ” Waiting for ${CONTAINER_NAME} to become healthy..."
        for i in {1..30}; do
          HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' ${CONTAINER_NAME} 2>/dev/null || echo "starting")
          if [ "${HEALTH_STATUS}" == "healthy" ]; then
            echo "âœ… ${CONTAINER_NAME} is healthy!"
            exit 0
          fi
          echo "   - Waiting... (Status: ${HEALTH_STATUS})"
          sleep 10
        done
        echo "âŒ ${CONTAINER_NAME} failed to become healthy. Aborting."
        docker compose logs "portfolio-${{ env.DEPLOY_SLOT }}"
        exit 1

    - name: 8. Switch Traffic (Zero Downtime)
      run: |
        echo "ðŸ”„ Switching traffic from ${{ env.LIVE_SLOT }} to ${{ env.DEPLOY_SLOT }}..."
        
        # Atomically switch the upstream by overwriting the include file.
        # This is much safer than using sed.
        echo "set \$active_upstream daniel-koryat-portfolio-${{ env.DEPLOY_SLOT }}:3000;" > active_upstream.conf

        # Perform a graceful reload to apply the change with zero downtime.
        echo "Performing graceful nginx reload..."
        docker compose exec nginx nginx -s reload
        echo "âœ… Traffic switched!"

    - name: 9. Clean Up Old Environment
      run: |
        echo "ðŸ›‘ Stopping the old ${{ env.LIVE_SLOT }} container..."
        docker compose stop "portfolio-${{ env.LIVE_SLOT }}"

    - name: 10. Show Final Status
      run: |
        echo "ðŸŽ‰ Zero-downtime deployment complete!"
        docker compose ps